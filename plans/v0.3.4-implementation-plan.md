# v0.3.4 Implementation Plan: Production Hardening

## Overview

Release v0.3.4 focuses on **production hardening**, **code debt cleanup**, and **developer experience improvements**. This plan covers 5 issues with detailed implementation guidance.

**Theme**: "Rock Solid Foundation"

**Scope**: #76, #95, #97, #96, #72

---

## ‚ö†Ô∏è Breaking Changes Notice

This release contains **2 breaking changes** that affect existing users:

| Issue | Breaking Change | Migration |
|-------|----------------|-----------|
| #97 | Compact error messages now default | Add `verbose_errors=True` to restore previous behavior |
| #72 | Status value "failed" ‚Üí "error" | Update client code parsing status values |

---

## Implementation Order

```
#76 CI/CD ‚Üí #72 Status ‚Üí #95 Error Handler ‚Üí #97 Compact Errors ‚Üí #96 Validation
```

**Rationale**:
1. CI/CD first ensures all subsequent changes get automated testing
2. Status consistency is trivial (1-line fix)
3. Error handler refactor must complete before compact errors (dependencies)
4. Validation standardization is independent, can be parallelized

---

## Issue #76: CI/CD GitHub Actions Workflows

### Summary
Add foundational CI/CD infrastructure: automated lint, type-check, test, coverage, and release workflows.

### Files to Create

```
.github/
‚îú‚îÄ‚îÄ workflows/
‚îÇ   ‚îú‚îÄ‚îÄ ci.yml           # Lint, type-check, test
‚îÇ   ‚îî‚îÄ‚îÄ release.yml      # PyPI publish on tag
‚îú‚îÄ‚îÄ codecov.yml          # Coverage configuration (optional)
‚îî‚îÄ‚îÄ dependabot.yml       # Dependency updates (optional)
```

### Implementation

#### `.github/workflows/ci.yml`

```yaml
name: CI

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  lint:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Install uv
        uses: astral-sh/setup-uv@v7
        with:
          enable-cache: true
          version: "0.9.13"

      - name: Set up Python
        run: uv python install 3.12

      - name: Install dependencies
        run: uv sync --all-groups

      - name: Lint with Ruff
        run: |
          uv run ruff check . --output-format=github
          uv run ruff format --check .

  type-check:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Install uv
        uses: astral-sh/setup-uv@v7
        with:
          enable-cache: true
          version: "0.9.13"

      - name: Set up Python
        run: uv python install 3.12

      - name: Install dependencies
        run: uv sync --all-groups

      - name: Type check with Mypy
        run: uv run mypy src/ --ignore-missing-imports

  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Install uv
        uses: astral-sh/setup-uv@v7
        with:
          enable-cache: true
          version: "0.9.13"

      - name: Set up Python
        run: uv python install 3.12

      - name: Install dependencies
        run: uv sync --all-groups

      - name: Run tests with coverage
        run: |
          uv run pytest \
            -m "not requires_snowflake" \
            --cov=src/igloo_mcp \
            --cov-report=xml \
            --cov-report=term-missing \
            -v

      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v5
        with:
          token: ${{ secrets.CODECOV_TOKEN }}
          files: ./coverage.xml
          flags: unittests
          fail_ci_if_error: false
          verbose: true
```

#### `.github/workflows/release.yml`

```yaml
name: Release to PyPI

on:
  push:
    tags:
      - 'v*'

jobs:
  publish:
    runs-on: ubuntu-latest
    environment:
      name: pypi
    permissions:
      id-token: write
      contents: read

    steps:
      - uses: actions/checkout@v4

      - name: Install uv
        uses: astral-sh/setup-uv@v7
        with:
          version: "0.9.13"

      - name: Set up Python
        run: uv python install 3.12

      - name: Build package
        run: uv build

      - name: Publish to PyPI
        run: uv publish
        env:
          UV_PUBLISH_TOKEN: ${{ secrets.PYPI_API_TOKEN }}
```

### Required Secrets

| Secret | Purpose | Where to Get |
|--------|---------|--------------|
| `PYPI_API_TOKEN` | PyPI publish | https://pypi.org/manage/account/token/ |
| `CODECOV_TOKEN` | Coverage upload | https://app.codecov.io/gh/Evan-Kim2028/igloo-mcp/settings |

### Local CI Commands

```bash
# Run exact CI steps locally
uv run ruff check . && uv run ruff format --check . && uv run mypy src/ --ignore-missing-imports && uv run pytest -m "not requires_snowflake" --cov=src/igloo_mcp
```

### Acceptance Criteria

- [ ] CI runs on every push to main and every PR
- [ ] Lint, type-check, and test jobs run in parallel
- [ ] Tests skip Snowflake integration tests (`-m "not requires_snowflake"`)
- [ ] Coverage uploaded to Codecov
- [ ] PyPI release triggered by tag creation (e.g., `git tag v0.3.4`)
- [ ] All existing tests pass in CI environment

---

## Issue #72: Standardize Error Status Values

### Summary
Fix inconsistent status values: change "failed" to "error" in health.py.

### Files to Modify

| File | Line | Current | Change To |
|------|------|---------|-----------|
| `src/igloo_mcp/mcp/tools/health.py` | 197 | `"status": "failed"` | `"status": "error"` |

### Implementation

```python
# src/igloo_mcp/mcp/tools/health.py:197
# Before:
return {
    "status": "failed",
    "connected": False,
    ...
}

# After:
return {
    "status": "error",
    "connected": False,
    ...
}
```

### Future Enhancement (Optional)

Create `ToolStatus` enum for type safety:

```python
# src/igloo_mcp/mcp/status.py
from enum import Enum

class ToolStatus(str, Enum):
    """Standard status values for MCP tool responses."""
    SUCCESS = "success"
    ERROR = "error"
    INVALID = "invalid"
    UNAVAILABLE = "unavailable"
```

### Acceptance Criteria

- [ ] All tools return "error" for error conditions (no "failed")
- [ ] Tests updated to check for "error" status
- [ ] Breaking change documented in release notes

---

## Issue #95: Refactor tool_error_handler

### Summary
Extract common error handling logic from `tool_error_handler` decorator to eliminate ~100 lines of duplication between async and sync wrappers.

### Current State

Location: `src/igloo_mcp/mcp/tools/base.py:157-357`

```
async_wrapper: ~100 lines (170-270)
sync_wrapper: ~100 lines (275-357)
Total: ~200 lines with significant duplication
```

### Proposed Extraction

Create shared helper functions in `src/igloo_mcp/mcp/error_utils.py`:

```python
# src/igloo_mcp/mcp/error_utils.py (add to existing file)

def handle_mcp_exception(
    e: MCPToolError,
    request_id: str,
    tool_name: str,
    logger: Logger,
) -> None:
    """Handle MCP exceptions - log and re-raise."""
    logger.error(
        f"MCP tool error in {tool_name}",
        extra={
            "request_id": request_id,
            "error_code": e.error_code,
            "tool_name": tool_name,
        },
        exc_info=True,
    )
    raise


def handle_validation_error(
    e: ValidationError,
    request_id: str,
    tool_name: str,
    logger: Logger,
) -> MCPValidationError:
    """Convert Pydantic ValidationError to MCPValidationError."""
    logger.warning(
        f"Validation error in {tool_name}",
        extra={
            "request_id": request_id,
            "tool_name": tool_name,
            "validation_errors": str(e.errors()),
        },
    )
    return MCPValidationError(
        message=f"Parameter validation failed for {tool_name}",
        validation_errors=[str(err) for err in e.errors()],
        hints=["Check parameter types and values"],
        request_id=request_id,
    )


def handle_generic_exception(
    e: Exception,
    request_id: str,
    tool_name: str,
    logger: Logger,
) -> MCPExecutionError:
    """Convert generic exception to MCPExecutionError."""
    logger.exception(
        f"Unexpected error in {tool_name}",
        extra={
            "request_id": request_id,
            "tool_name": tool_name,
            "error_type": type(e).__name__,
        },
    )
    return MCPExecutionError(
        message=f"Tool execution failed: {str(e)[:100]}",
        operation=tool_name,
        hints=["Check logs for full stack trace"],
        request_id=request_id,
    )
```

### Refactored Decorator

```python
# src/igloo_mcp/mcp/tools/base.py

def tool_error_handler(tool_name: str):
    """Decorator for consistent error handling in MCP tools."""

    def decorator(func: Callable) -> Callable:
        if asyncio.iscoroutinefunction(func):
            @functools.wraps(func)
            async def async_wrapper(*args, **kwargs):
                request_id = kwargs.get("request_id") or ensure_request_id(None)
                try:
                    return await func(*args, **kwargs)
                except MCPToolError:
                    raise  # Already an MCP error, re-raise as-is
                except ValidationError as e:
                    raise handle_validation_error(e, request_id, tool_name, logger)
                except Exception as e:
                    raise handle_generic_exception(e, request_id, tool_name, logger)
            return async_wrapper
        else:
            @functools.wraps(func)
            def sync_wrapper(*args, **kwargs):
                request_id = kwargs.get("request_id") or ensure_request_id(None)
                try:
                    return func(*args, **kwargs)
                except MCPToolError:
                    raise
                except ValidationError as e:
                    raise handle_validation_error(e, request_id, tool_name, logger)
                except Exception as e:
                    raise handle_generic_exception(e, request_id, tool_name, logger)
            return sync_wrapper
    return decorator
```

### Line Count Target

| Component | Before | After |
|-----------|--------|-------|
| async_wrapper | ~100 | ~20 |
| sync_wrapper | ~100 | ~20 |
| error_utils.py helpers | 0 | ~60 |
| **Total** | ~200 | ~100 |

### Acceptance Criteria

- [ ] Extracted helpers in error_utils.py with unit tests
- [ ] async_wrapper and sync_wrapper use identical helper calls
- [ ] Total line count reduced by ~100 lines
- [ ] All existing MCP tool tests pass
- [ ] No change in error handling behavior
- [ ] request_id preserved in all error paths

---

## Issue #97: Compact Error Messages

### Summary
Default to compact error messages (1-2 hints) to reduce token usage by 60%+. Add `verbose_errors=True` opt-in for full hints.

### Current State

- Errors include 4+ hints by default
- Each error: ~200-500 tokens
- No control over verbosity

### Proposed Design

#### 1. Add Compact Mode to Exceptions

```python
# src/igloo_mcp/mcp/exceptions.py

class MCPToolError(Exception):
    """Base exception for MCP tool errors."""

    DEFAULT_MAX_HINTS = 2  # Compact mode default

    def __init__(
        self,
        message: str,
        error_code: str,
        hints: list[str] | None = None,
        context: dict | None = None,
        request_id: str | None = None,
        verbose: bool = False,  # NEW: Control hint verbosity
    ):
        self.message = message
        self.error_code = error_code
        self._all_hints = hints or []
        self.context = context or {}
        self.request_id = request_id
        self.verbose = verbose
        super().__init__(message)

    @property
    def hints(self) -> list[str]:
        """Return hints based on verbosity setting."""
        if self.verbose:
            return self._all_hints
        return self._all_hints[:self.DEFAULT_MAX_HINTS]

    def to_dict(self) -> dict:
        """Convert exception to response dictionary."""
        result = {
            "status": "error",
            "error_code": self.error_code,
            "message": self.message,
            "hints": self.hints,
            "request_id": self.request_id,
        }

        # Add truncation notice in compact mode
        if not self.verbose and len(self._all_hints) > self.DEFAULT_MAX_HINTS:
            result["hints_truncated"] = True
            result["hints_available"] = len(self._all_hints)

        return result
```

#### 2. Propagate verbose_errors Through Error Utils

```python
# src/igloo_mcp/mcp/error_utils.py

def wrap_timeout_error(
    e: Exception,
    statement: str,
    timeout_seconds: float,
    request_id: str | None = None,
    verbose: bool = False,  # NEW
) -> MCPExecutionError:
    """Wrap timeout errors with contextual hints."""
    hints = [
        "Increase timeout_seconds parameter",
        "Add WHERE clause to filter results",
        "Use LIMIT clause",
        "Check warehouse size",
        "Consider query optimization",  # These hints won't show in compact mode
    ]

    return MCPExecutionError(
        message=f"Query timed out after {timeout_seconds}s",
        operation="execute_query",
        hints=hints,
        request_id=request_id,
        verbose=verbose,  # Pass through
    )
```

#### 3. Add verbose_errors Parameter to Tools

```python
# src/igloo_mcp/mcp/tools/execute_query.py

async def execute(
    self,
    statement: str,
    timeout_seconds: float = 480.0,
    verbose_errors: bool = False,  # NEW: Default compact
    request_id: str | None = None,
) -> dict:
    """Execute SQL query."""
    try:
        # ... execution logic ...
    except TimeoutError as e:
        raise wrap_timeout_error(
            e,
            statement=statement,
            timeout_seconds=timeout_seconds,
            request_id=request_id,
            verbose=verbose_errors,
        )
```

### Token Reduction Verification

Create test to verify 60% reduction:

```python
# tests/test_compact_errors.py

import tiktoken

def count_tokens(text: str) -> int:
    """Count tokens using cl100k_base encoding."""
    enc = tiktoken.get_encoding("cl100k_base")
    return len(enc.encode(str(text)))

def test_compact_errors_reduce_tokens():
    """Verify compact errors reduce token usage by 60%+."""
    # Create error with many hints
    error = MCPExecutionError(
        message="Query timed out after 480s",
        operation="execute_query",
        hints=[
            "Increase timeout_seconds parameter",
            "Add WHERE clause to filter results",
            "Use LIMIT clause to reduce result size",
            "Check warehouse size and scaling",
            "Consider query optimization strategies",
        ],
        verbose=False,
    )

    compact_tokens = count_tokens(str(error.to_dict()))

    error.verbose = True
    verbose_tokens = count_tokens(str(error.to_dict()))

    reduction = (verbose_tokens - compact_tokens) / verbose_tokens
    assert reduction >= 0.60, f"Token reduction was only {reduction:.1%}"
```

### Acceptance Criteria

- [ ] Default error messages have max 2 hints
- [ ] `verbose_errors=True` shows all hints
- [ ] `hints_truncated: true` and `hints_available: N` indicate truncation
- [ ] Token usage reduced by 60%+ on representative errors
- [ ] All exception subclasses support verbose parameter
- [ ] Logs always contain full error details (verbose internally)
- [ ] Breaking change documented in release notes

---

## Issue #96: Standardize Parameter Validation

### Summary
Move parameter validation from `execute()` methods to `validate_parameters()` method. Create shared validation helpers.

### Current State

Validation scattered across execute() methods:

```python
# src/igloo_mcp/mcp/tools/execute_query.py
async def execute(self, statement: str, timeout_seconds: float = 480.0, ...):
    # Validation inside execute
    if not statement or not statement.strip():
        raise MCPValidationError(...)
    if timeout_seconds < 1 or timeout_seconds > 3600:
        raise MCPValidationError(...)
```

### Proposed Pattern

#### 1. Create Validation Helpers

```python
# src/igloo_mcp/mcp/validation_helpers.py (add to existing)

from typing import Any, TypeVar

T = TypeVar("T")


def validate_required_string(
    value: Any,
    field_name: str,
    min_length: int = 1,
    max_length: int | None = None,
) -> str:
    """Validate required string parameter."""
    if value is None:
        raise MCPValidationError(
            message=f"{field_name} is required",
            validation_errors=[f"{field_name} cannot be None"],
            hints=[f"Provide a valid {field_name}"],
        )

    if not isinstance(value, str):
        raise MCPValidationError(
            message=f"{field_name} must be a string",
            validation_errors=[f"Expected string, got {type(value).__name__}"],
            hints=[f"Provide {field_name} as a string"],
        )

    value = value.strip()
    if len(value) < min_length:
        raise MCPValidationError(
            message=f"{field_name} cannot be empty",
            validation_errors=[f"{field_name} must be at least {min_length} characters"],
            hints=[f"Provide a non-empty {field_name}"],
        )

    if max_length and len(value) > max_length:
        raise MCPValidationError(
            message=f"{field_name} exceeds maximum length",
            validation_errors=[f"{field_name} must be at most {max_length} characters"],
            hints=[f"Reduce {field_name} length to {max_length} or less"],
        )

    return value


def validate_numeric_range(
    value: Any,
    field_name: str,
    min_value: float | None = None,
    max_value: float | None = None,
    allow_none: bool = False,
) -> float | None:
    """Validate numeric parameter within range."""
    if value is None:
        if allow_none:
            return None
        raise MCPValidationError(
            message=f"{field_name} is required",
            validation_errors=[f"{field_name} cannot be None"],
            hints=[f"Provide a valid {field_name}"],
        )

    try:
        numeric_value = float(value)
    except (TypeError, ValueError):
        raise MCPValidationError(
            message=f"{field_name} must be a number",
            validation_errors=[f"Cannot convert {value!r} to number"],
            hints=[f"Provide {field_name} as a number (e.g., 480.0)"],
        )

    if min_value is not None and numeric_value < min_value:
        raise MCPValidationError(
            message=f"{field_name} below minimum",
            validation_errors=[f"{field_name}={numeric_value} is below minimum {min_value}"],
            hints=[f"Increase {field_name} to at least {min_value}"],
        )

    if max_value is not None and numeric_value > max_value:
        raise MCPValidationError(
            message=f"{field_name} exceeds maximum",
            validation_errors=[f"{field_name}={numeric_value} exceeds maximum {max_value}"],
            hints=[f"Reduce {field_name} to at most {max_value}"],
        )

    return numeric_value


def validate_enum_value(
    value: Any,
    field_name: str,
    allowed_values: list[str],
    allow_none: bool = False,
) -> str | None:
    """Validate string is one of allowed values."""
    if value is None:
        if allow_none:
            return None
        raise MCPValidationError(
            message=f"{field_name} is required",
            validation_errors=[f"{field_name} cannot be None"],
            hints=[f"Choose one of: {', '.join(allowed_values)}"],
        )

    if value not in allowed_values:
        raise MCPValidationError(
            message=f"Invalid {field_name}",
            validation_errors=[f"{value!r} is not a valid {field_name}"],
            hints=[f"Choose one of: {', '.join(allowed_values)}"],
        )

    return value
```

#### 2. Implement validate_parameters() in Tools

```python
# src/igloo_mcp/mcp/tools/execute_query.py

from igloo_mcp.mcp.validation_helpers import (
    validate_required_string,
    validate_numeric_range,
)


class ExecuteQueryTool(MCPTool):

    def validate_parameters(self, **kwargs) -> dict:
        """Validate all parameters before execution."""
        return {
            "statement": validate_required_string(
                kwargs.get("statement"),
                field_name="statement",
                min_length=1,
            ),
            "timeout_seconds": validate_numeric_range(
                kwargs.get("timeout_seconds", 480.0),
                field_name="timeout_seconds",
                min_value=1.0,
                max_value=3600.0,
            ),
            "verbose_errors": kwargs.get("verbose_errors", False),
            "request_id": kwargs.get("request_id"),
        }

    async def execute(
        self,
        statement: str,
        timeout_seconds: float = 480.0,
        verbose_errors: bool = False,
        request_id: str | None = None,
    ) -> dict:
        """Execute SQL query."""
        # Validation now happens in validate_parameters()
        # execute() can assume parameters are valid

        request_id = ensure_request_id(request_id)
        # ... rest of execution logic ...
```

### Migration Order

1. **execute_query** - Most complex, most validation
2. **evolve_report** - Complex validation with multiple params
3. **build_catalog** - Moderate validation
4. **render_report** - Moderate validation
5. **health** - Simple validation
6. **search_report** - Simple validation

### Acceptance Criteria

- [ ] All tools use `validate_parameters()` for parameter validation
- [ ] No validation logic remains in `execute()` methods
- [ ] Shared validation helpers have comprehensive unit tests
- [ ] Validation errors use consistent message format
- [ ] All existing tests pass

---

## Testing Strategy

### New Test Files

```
tests/
‚îú‚îÄ‚îÄ test_ci_local.py              # Verify CI commands work locally
‚îú‚îÄ‚îÄ test_compact_errors.py        # Token reduction verification
‚îú‚îÄ‚îÄ test_validation_helpers.py    # Validation helper unit tests
‚îî‚îÄ‚îÄ test_error_handler_refactor.py # Error handler helper tests
```

### Test Categories

| Category | Tests | Purpose |
|----------|-------|---------|
| Unit | validation_helpers | Test each helper in isolation |
| Unit | error_handler_helpers | Test extracted error handling |
| Integration | compact_errors | Verify token reduction |
| Regression | existing_tools | Ensure no behavior change |

### Token Reduction Test Suite

```python
# tests/test_compact_errors.py

REPRESENTATIVE_ERRORS = [
    ("timeout", create_timeout_error()),
    ("validation", create_validation_error()),
    ("execution", create_execution_error()),
    ("selector", create_selector_error()),
]

@pytest.mark.parametrize("name,error", REPRESENTATIVE_ERRORS)
def test_compact_reduces_tokens(name, error):
    """Each error type should have 60%+ token reduction."""
    # Test implementation
```

---

## Documentation Updates

### Files to Update

| File | Update |
|------|--------|
| `CHANGELOG.md` | Add v0.3.4 section with breaking changes |
| `README.md` | Update error handling section |
| `docs/api/ERROR_CATALOG.md` | Document compact vs verbose modes |

### Release Notes Template

```markdown
## v0.3.4 - Production Hardening

### ‚ö†Ô∏è Breaking Changes

- **Compact Error Messages**: Error responses now default to compact format (max 2 hints).
  To restore verbose errors: `execute_query(..., verbose_errors=True)`

- **Status Value Standardization**: Health check failures now return `"status": "error"`
  instead of `"status": "failed"`. Update client code accordingly.

### ‚ú® New Features

- **CI/CD Workflows**: Automated testing, linting, and PyPI releases via GitHub Actions
- **Codecov Integration**: Coverage tracking on pull requests

### üîß Improvements

- **Error Handler Refactor**: Reduced code duplication by ~100 lines
- **Validation Standardization**: Consistent parameter validation across all tools
- **Token Efficiency**: 60%+ reduction in error message tokens
```

---

## Checklist Summary

### Must Complete

- [ ] #76: Create `.github/workflows/ci.yml`
- [ ] #76: Create `.github/workflows/release.yml`
- [ ] #76: Configure PYPI_API_TOKEN secret
- [ ] #76: Configure CODECOV_TOKEN secret
- [ ] #72: Change "failed" to "error" in health.py:197
- [ ] #95: Extract error handling helpers to error_utils.py
- [ ] #95: Refactor tool_error_handler to use helpers
- [ ] #97: Add verbose parameter to MCPToolError and subclasses
- [ ] #97: Add verbose_errors parameter to all tools
- [ ] #97: Add hints_truncated indicator
- [ ] #96: Create validation helpers
- [ ] #96: Migrate execute_query to use validate_parameters()
- [ ] All: Update CHANGELOG.md with breaking changes
- [ ] All: All existing tests pass

### Verification

- [ ] CI runs successfully on test PR
- [ ] Token reduction verified at 60%+
- [ ] Line count reduction verified at ~100 lines
- [ ] No regressions in tool behavior

---

## References

### File Paths

| Purpose | Path |
|---------|------|
| Error handler decorator | `src/igloo_mcp/mcp/tools/base.py:157-357` |
| Error utilities | `src/igloo_mcp/mcp/error_utils.py` |
| Exceptions | `src/igloo_mcp/mcp/exceptions.py` |
| Validation helpers | `src/igloo_mcp/mcp/validation_helpers.py` |
| Health tool | `src/igloo_mcp/mcp/tools/health.py` |
| Execute query | `src/igloo_mcp/mcp/tools/execute_query.py` |
| Test config | `pyproject.toml:82-140` |

### External Docs

- [astral-sh/setup-uv](https://github.com/astral-sh/setup-uv)
- [Codecov GitHub Action](https://github.com/codecov/codecov-action)
- [Tenacity](https://tenacity.readthedocs.io/)
